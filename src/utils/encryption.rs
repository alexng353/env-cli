use anyhow::{anyhow, Context};
use std::process::Stdio;
use tokio::{io::AsyncWriteExt, process::Command};

use crate::errors::ERR;

pub(crate) async fn encrypt(
    recipient: String,
    text: String,
) -> anyhow::Result<String, anyhow::Error> {
    let mut gpg = Command::new("gpg")
        .arg("--batch")
        .arg("--yes")
        .arg("--encrypt")
        .arg("--armor")
        .arg("--recipient")
        .arg("--quiet")
        .arg(recipient)
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .spawn()
        .context(ERR::GpgError)?;

    {
        let stdin = gpg.stdin.as_mut().expect("Failed to open stdin");
        stdin.write_all(text.as_bytes()).await?;
    }

    let output = gpg.wait_with_output().await?;

    if output.status.success() {
        Ok(String::from_utf8(output.stdout)?)
    } else {
        Err(anyhow::Error::msg(String::from_utf8(output.stderr)?))
    }
}

pub(crate) async fn decrypt(text: String) -> anyhow::Result<String, anyhow::Error> {
    let mut gpg = Command::new("gpg")
        .arg("--yes")
        .arg("--quiet")
        .arg("-d")
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .spawn()
        .context(ERR::GpgError)?;

    {
        let stdin = gpg.stdin.as_mut().expect("Failed to open stdin");
        stdin.write_all(text.as_bytes()).await?;
    }

    let output = gpg.wait_with_output().await?;

    if output.status.success() {
        Ok(String::from_utf8(output.stdout)?)
    } else {
        Err(anyhow::Error::msg(String::from_utf8(output.stderr)?))
    }
}

pub(crate) fn generate_gpg_config(
    name: &str,
    email: &str,
    passphrase: &str,
    number: &i32,
) -> anyhow::Result<String, anyhow::Error> {
    let config = format!(
        indoc::indoc! {
        "Key-Type: RSA
        Key-Length: 4096
        Name-Real: {name}
        Name-Email: {email}
        Name-Comment: env-store encryption key generated by env-cli {number}
        Expire-Date: 0
        Passphrase: {passphrase}
        %commit"
        },
        name = name,
        email = email,
        number = number,
        passphrase = passphrase
    );

    Ok(config.into())
}

pub(crate) async fn gpg_list_keys() -> anyhow::Result<Vec<String>, anyhow::Error> {
    let output = Command::new("gpg")
        .arg("--list-keys")
        .output()
        .await
        .context("Failed to spawn gpg")?;

    /*pub   rsa4096 2023-05-22 [SCEA]
        26B6379AC0699BAC9422067C5CD40A64D0647BCE
    uid           [ultimate] Alexander Ng (env-store encryption key generated by env-cli) <alexng353@gmail.com> */

    let stdout = String::from_utf8(output.stdout)?;
    // i only want the fingerprint, so we look for (env-store encryption key generated by env-cli)
    // output the index of the line above it
    // grab the line above it using split collect<Vec_>

    let split_stdout = stdout.split("\n").collect::<Vec<_>>();

    let indices: Vec<usize> = split_stdout
        .iter()
        .enumerate()
        .filter_map(|(index, s)| {
            if s.contains("(env-store encryption key generated by env-cli") {
                Some(index)
            } else {
                None
            }
        })
        .collect();

    if indices.is_empty() {
        return Err(anyhow!("Failed to find key"));
    }

    let fingerprints = indices
        .iter()
        .map(|index| split_stdout[*index - 1].trim().to_string())
        .collect::<Vec<String>>();

    if output.status.success() {
        Ok(fingerprints)
    } else {
        Err(anyhow!("Failed to list keys"))
    }
}

pub(crate) async fn gpg_generate_key(
    name: &str,
    email: &str,
    passphrase: &str,
    number: &i32,
) -> anyhow::Result<(), anyhow::Error> {
    let config = generate_gpg_config(&name, &email, &passphrase, &number).unwrap();

    let mut gpg = Command::new("gpg")
        .arg("--batch")
        .arg("--gen-key")
        .stdin(std::process::Stdio::piped())
        .spawn()
        .context("Failed to spawn gpg")?;

    {
        let stdin = gpg.stdin.as_mut().context("Failed to open stdin")?;
        stdin.write_all(config.as_bytes()).await?;
    }

    let output = gpg.wait_with_output().await?;
    println!("{:?}", output);

    if output.status.success() {
        anyhow::Ok(())
    } else {
        Err(anyhow!("Failed to generate key"))
    }
}
